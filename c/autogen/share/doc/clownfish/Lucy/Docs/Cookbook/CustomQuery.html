<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<!--
***********************************************

!!!! DO NOT EDIT !!!!

This file was auto-generated by cfc.

***********************************************

Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<meta name="viewport" content="width=device-width" />
<title>Lucy::Docs::Cookbook::CustomQuery</title>
<style type="text/css">
body {
    max-width: 48em;
    font: 0.85em/1.4 sans-serif;
}
a {
    color: #23b;
}
table {
    border-collapse: collapse;
}
td {
    padding: 0;
}
td.label {
    padding-right: 2em;
    font-weight: bold;
}
dt {
    font-weight: bold;
}
pre {
    border: 1px solid #ccc;
    padding: 0.2em 0.4em;
    background: #f6f6f6;
    font-size: 0.92em;
}
pre a {
    text-decoration: none;
}
pre, code {
    font-family: "Consolas", "Menlo", monospace;
}
span.prefix, span.comment {
    color: #888;
}
</style>
</head>
<body>
<h1>Sample subclass of Query</h1>
<p>Explore Apache Lucy’s support for custom query types by creating a
“PrefixQuery” class to handle trailing wildcards.</p>
<pre><code>Code example for C is missing</code></pre>
<h2>Query, Compiler, and Matcher</h2>
<p>To add support for a new query type, we need three classes: a Query, a
Compiler, and a Matcher.</p>
<ul>
<li>
<p>PrefixQuery - a subclass of <a href="../../../Lucy/Search/Query.html">Query</a>, and the only class
that client code will deal with directly.</p>
</li>
<li>
<p>PrefixCompiler - a subclass of <a href="../../../Lucy/Search/Compiler.html">Compiler</a>, whose primary
role is to compile a PrefixQuery to a PrefixMatcher.</p>
</li>
<li>
<p>PrefixMatcher - a subclass of <a href="../../../Lucy/Search/Matcher.html">Matcher</a>, which does the
heavy lifting: it applies the query to individual documents and assigns a
score to each match.</p>
</li>
</ul>
<p>The PrefixQuery class on its own isn’t enough because a Query object’s role is
limited to expressing an abstract specification for the search.  A Query is
basically nothing but metadata; execution is left to the Query’s companion
Compiler and Matcher.</p>
<p>Here’s a simplified sketch illustrating how a Searcher’s hits() method ties
together the three classes.</p>
<pre><code>Code example for C is missing</code></pre>
<h3>PrefixQuery</h3>
<p>Our PrefixQuery class will have two attributes: a query string and a field
name.</p>
<pre><code>Code example for C is missing</code></pre>
<p>PrefixQuery’s constructor collects and validates the attributes.</p>
<pre><code>Code example for C is missing</code></pre>
<p>Since this is an inside-out class, we’ll need a destructor:</p>
<pre><code>Code example for C is missing</code></pre>
<p>The equals() method determines whether two Queries are logically equivalent:</p>
<pre><code>Code example for C is missing</code></pre>
<p>The last thing we’ll need is a make_compiler() factory method which kicks out
a subclass of <a href="../../../Lucy/Search/Compiler.html">Compiler</a>.</p>
<pre><code>Code example for C is missing</code></pre>
<h3>PrefixCompiler</h3>
<p>PrefixQuery’s make_compiler() method will be called internally at search-time
by objects which subclass <a href="../../../Lucy/Search/Searcher.html">Searcher</a> – such as
<a href="../../../Lucy/Search/IndexSearcher.html">IndexSearchers</a>.</p>
<p>A Searcher is associated with a particular collection of documents.   These
documents may all reside in one index, as with IndexSearcher, or they may be
spread out across multiple indexes on one or more machines, as with
LucyX::Remote::ClusterSearcher.</p>
<p>Searcher objects have access to certain statistical information about the
collections they represent; for instance, a Searcher can tell you how many
documents are in the collection…</p>
<pre><code>Code example for C is missing</code></pre>
<p>… or how many documents a specific term appears in:</p>
<pre><code>Code example for C is missing</code></pre>
<p>Such information can be used by sophisticated Compiler implementations to
assign more or less heft to individual queries or sub-queries.  However, we’re
not going to bother with weighting for this demo; we’ll just assign a fixed
score of 1.0 to each matching document.</p>
<p>We don’t need to write a constructor, as it will suffice to inherit new() from
Lucy::Search::Compiler.  The only method we need to implement for
PrefixCompiler is make_matcher().</p>
<pre><code>Code example for C is missing</code></pre>
<p>PrefixCompiler gets access to a <a href="../../../Lucy/Index/SegReader.html">SegReader</a>
object when make_matcher() gets called.  From the SegReader and its
sub-components <a href="../../../Lucy/Index/LexiconReader.html">LexiconReader</a> and
<a href="../../../Lucy/Index/PostingListReader.html">PostingListReader</a>, we acquire a
<a href="../../../Lucy/Index/Lexicon.html">Lexicon</a>, scan through the Lexicon’s unique
terms, and acquire a <a href="../../../Lucy/Index/PostingList.html">PostingList</a> for each
term that matches our prefix.</p>
<p>Each of these PostingList objects represents a set of documents which match
the query.</p>
<h3>PrefixMatcher</h3>
<p>The Matcher subclass is the most involved.</p>
<pre><code>Code example for C is missing</code></pre>
<p>The doc ids must be in order, or some will be ignored; hence the <code>sort</code>
above.</p>
<p>In addition to the constructor and destructor, there are three methods that
must be overridden.</p>
<p>next() advances the Matcher to the next valid matching doc.</p>
<pre><code>Code example for C is missing</code></pre>
<p>get_doc_id() returns the current document id, or 0 if the Matcher is
exhausted.  (<a href="../../../Lucy/Docs/DocIDs.html">Document numbers</a> start at 1, so 0 is
a sentinel.)</p>
<pre><code>Code example for C is missing</code></pre>
<p>score() conveys the relevance score of the current match.  We’ll just return a
fixed score of 1.0:</p>
<pre><code>Code example for C is missing</code></pre>
<h2>Usage</h2>
<p>To get a basic feel for PrefixQuery, insert the FlatQueryParser module
described in <a href="../../../Lucy/Docs/Cookbook/CustomQueryParser.html">CustomQueryParser</a> (which supports
PrefixQuery) into the search.cgi sample app.</p>
<pre><code>Code example for C is missing</code></pre>
<p>If you’re planning on using PrefixQuery in earnest, though, you may want to
change up analyzers to avoid stemming, because stemming – another approach to
prefix conflation – is not perfectly compatible with prefix searches.</p>
<pre><code>Code example for C is missing</code></pre>
</body>
</html>

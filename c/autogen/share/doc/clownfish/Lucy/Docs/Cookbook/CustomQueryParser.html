<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<!--
***********************************************

!!!! DO NOT EDIT !!!!

This file was auto-generated by cfc.

***********************************************

Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<meta name="viewport" content="width=device-width" />
<title>Lucy::Docs::Cookbook::CustomQueryParser</title>
<style type="text/css">
body {
    max-width: 48em;
    font: 0.85em/1.4 sans-serif;
}
a {
    color: #23b;
}
table {
    border-collapse: collapse;
}
td {
    padding: 0;
}
td.label {
    padding-right: 2em;
    font-weight: bold;
}
dt {
    font-weight: bold;
}
pre {
    border: 1px solid #ccc;
    padding: 0.2em 0.4em;
    background: #f6f6f6;
    font-size: 0.92em;
}
pre a {
    text-decoration: none;
}
pre, code {
    font-family: "Consolas", "Menlo", monospace;
}
span.prefix, span.comment {
    color: #888;
}
</style>
</head>
<body>
<h1>Sample subclass of QueryParser.</h1>
<p>Implement a custom search query language using a subclass of
<a href="../../../Lucy/Search/QueryParser.html">QueryParser</a>.</p>
<h2>The language</h2>
<p>At first, our query language will support only simple term queries and phrases
delimited by double quotes.  For simplicity’s sake, it will not support
parenthetical groupings, boolean operators, or prepended plus/minus.  The
results for all subqueries will be unioned together – i.e. joined using an OR
– which is usually the best approach for small-to-medium-sized document
collections.</p>
<p>Later, we’ll add support for trailing wildcards.</p>
<h2>Single-field parser</h2>
<p>Our initial parser implentation will generate queries against a single fixed
field, “content”, and it will analyze text using a fixed choice of English
EasyAnalyzer.  We won’t subclass Lucy::Search::QueryParser just yet.</p>
<pre><code>Code example for C is missing</code></pre>
<p>Some private helper subs for creating TermQuery and PhraseQuery objects will
help keep the size of our main parse() subroutine down:</p>
<pre><code>Code example for C is missing</code></pre>
<p>Our private _tokenize() method treats double-quote delimited material as a
single token and splits on whitespace everywhere else.</p>
<pre><code>Code example for C is missing</code></pre>
<p>The main parsing routine creates an array of tokens by calling _tokenize(),
runs the tokens through through the EasyAnalyzer, creates TermQuery or
PhraseQuery objects according to how many tokens emerge from the
EasyAnalyzer’s split() method, and adds each of the sub-queries to the primary
ORQuery.</p>
<pre><code>Code example for C is missing</code></pre>
<h2>Multi-field parser</h2>
<p>Most often, the end user will want their search query to match not only a
single ‘content’ field, but also ‘title’ and so on.  To make that happen, we
have to turn queries such as this…</p>
<pre><code>foo AND NOT bar
</code></pre>
<p>… into the logical equivalent of this:</p>
<pre><code>(title:foo OR content:foo) AND NOT (title:bar OR content:bar)
</code></pre>
<p>Rather than continue with our own from-scratch parser class and write the
routines to accomplish that expansion, we’re now going to subclass Lucy::Search::QueryParser
and take advantage of some of its existing methods.</p>
<p>Our first parser implementation had the “content” field name and the choice of
English EasyAnalyzer hard-coded for simplicity, but we don’t need to do that
once we subclass Lucy::Search::QueryParser.  QueryParser’s constructor –
which we will inherit, allowing us to eliminate our own constructor –
requires a Schema which conveys field
and Analyzer information, so we can just defer to that.</p>
<pre><code>Code example for C is missing</code></pre>
<p>We’re also going to jettison our _make_term_query() and _make_phrase_query()
helper subs and chop our parse() subroutine way down.  Our revised parse()
routine will generate Lucy::Search::LeafQuery objects instead of TermQueries
and PhraseQueries:</p>
<pre><code>Code example for C is missing</code></pre>
<p>The magic happens in QueryParser’s expand() method, which walks the ORQuery
object we supply to it looking for LeafQuery objects, and calls expand_leaf()
for each one it finds.  expand_leaf() performs field-specific analysis,
decides whether each query should be a TermQuery or a PhraseQuery, and if
multiple fields are required, creates an ORQuery which mults out e.g.  <code>foo</code>
into <code>(title:foo OR content:foo)</code>.</p>
<h2>Extending the query language</h2>
<p>To add support for trailing wildcards to our query language, we need to
override expand_leaf() to accommodate PrefixQuery, while deferring to the
parent class implementation on TermQuery and PhraseQuery.</p>
<pre><code>Code example for C is missing</code></pre>
<p>Ordinarily, those asterisks would have been stripped when running tokens
through the EasyAnalyzer – query strings containing “foo*” would produce
TermQueries for the term “foo”.  Our override intercepts tokens with trailing
asterisks and processes them as PrefixQueries before <code>SUPER::expand_leaf</code> can
discard them, so that a search for “foo*” can match “food”, “foosball”, and so
on.</p>
<h2>Usage</h2>
<p>Insert our custom parser into the search.cgi sample app to get a feel for how
it behaves:</p>
<pre><code>Code example for C is missing</code></pre>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<!--
***********************************************

!!!! DO NOT EDIT !!!!

This file was auto-generated by cfc.

***********************************************

Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<meta name="viewport" content="width=device-width" />
<title>Lucy::Docs::Tutorial::QueryObjectsTutorial</title>
<style type="text/css">
body {
    max-width: 48em;
    font: 0.85em/1.4 sans-serif;
}
a {
    color: #23b;
}
table {
    border-collapse: collapse;
}
td {
    padding: 0;
}
td.label {
    padding-right: 2em;
    font-weight: bold;
}
dt {
    font-weight: bold;
}
pre {
    border: 1px solid #ccc;
    padding: 0.2em 0.4em;
    background: #f6f6f6;
    font-size: 0.92em;
}
pre a {
    text-decoration: none;
}
pre, code {
    font-family: "Consolas", "Menlo", monospace;
}
span.prefix, span.comment {
    color: #888;
}
</style>
</head>
<body>
<h1>Use Query objects instead of query strings.</h1>
<p>Until now, our search app has had only a single search box.  In this tutorial
chapter, we’ll move towards an “advanced search” interface, by adding a
“category” drop-down menu.  Three new classes will be required:</p>
<ul>
<li>
<p><a href="../../../Lucy/Search/QueryParser.html">QueryParser</a> - Turn a query string into a
<a href="../../../Lucy/Search/Query.html">Query</a> object.</p>
</li>
<li>
<p><a href="../../../Lucy/Search/TermQuery.html">TermQuery</a> - Query for a specific term within
a specific field.</p>
</li>
<li>
<p><a href="../../../Lucy/Search/ANDQuery.html">ANDQuery</a> - “AND” together multiple Query
objects to produce an intersected result set.</p>
</li>
</ul>
<h2>Adaptations to indexer.pl</h2>
<p>Our new “category” field will be a StringType field rather than a FullTextType
field, because we will only be looking for exact matches.  It needs to be
indexed, but since we won’t display its value, it doesn’t need to be stored.</p>
<pre><code class="language-c">    {
        String *field_str = Str_newf(&quot;category&quot;);
        StringType *type = StringType_new();
        StringType_Set_Stored(type, false);
        Schema_Spec_Field(schema, field_str, (FieldType*)type);
        DECREF(type);
        DECREF(field_str);
    }
</code></pre>
<p>There will be three possible values: “article”, “amendment”, and “preamble”,
which we’ll hack out of the source file’s name during our <code>parse_file</code>
subroutine:</p>
<pre><code class="language-c">    const char *category = NULL;
    if (S_starts_with(filename, &quot;art&quot;)) {
        category = &quot;article&quot;;
    }
    else if (S_starts_with(filename, &quot;amend&quot;)) {
        category = &quot;amendment&quot;;
    }
    else if (S_starts_with(filename, &quot;preamble&quot;)) {
        category = &quot;preamble&quot;;
    }
    else {
        fprintf(stderr, &quot;Can't derive category for %s&quot;, filename);
        exit(1);
    }

    ...

    {
        // Store 'category' field
        String *field = Str_newf(&quot;category&quot;);
        String *value = Str_new_from_utf8(category, strlen(category));
        Doc_Store(doc, field, (Obj*)value);
        DECREF(field);
        DECREF(value);
    }
</code></pre>
<h2>Adaptations to search.cgi</h2>
<p>The “category” constraint will be added to our search interface using an HTML
“select” element (this routine will need to be integrated into the HTML
generation section of search.cgi):</p>
<pre><code class="language-c">static void
S_usage_and_exit(const char *arg0) {
    printf(&quot;Usage: %s [-c &lt;category&gt;] &lt;querystring&gt;\n&quot;, arg0);
    exit(1);
}
</code></pre>
<p>We’ll start off by loading our new modules and extracting our new CGI
parameter.</p>
<pre><code class="language-c">    const char *category = NULL;
    int i = 1;

    while (i &lt; argc - 1) {
        if (strcmp(argv[i], &quot;-c&quot;) == 0) {
            if (i + 1 &gt;= argc) {
                S_usage_and_exit(argv[0]);
            }
            i += 1;
            category = argv[i];
        }
        else {
            S_usage_and_exit(argv[0]);
        }

        i += 1;
    }

    if (i + 1 != argc) {
        S_usage_and_exit(argv[0]);
    }

    const char *query_c = argv[i];
</code></pre>
<p>QueryParser’s constructor requires a “schema” argument.  We can get that from
our IndexSearcher:</p>
<pre><code class="language-c">    IndexSearcher *searcher = IxSearcher_new((Obj*)folder);
    Schema        *schema   = IxSearcher_Get_Schema(searcher);
    QueryParser   *qparser  = QParser_new(schema, NULL, NULL, NULL);
</code></pre>
<p>Previously, we have been handing raw query strings to IndexSearcher.  Behind
the scenes, IndexSearcher has been using a QueryParser to turn those query
strings into Query objects.  Now, we will bring QueryParser into the
foreground and parse the strings explicitly.</p>
<pre><code class="language-c">    Query *query = QParser_Parse(qparser, query_str);
</code></pre>
<p>If the user has specified a category, we’ll use an ANDQuery to join our parsed
query together with a TermQuery representing the category.</p>
<pre><code class="language-c">    if (category) {
        String *category_name = String_newf(&quot;category&quot;);
        String *category_str  = String_newf(&quot;%s&quot;, category);
        TermQuery *category_query
            = TermQuery_new(category_name, category_str);

        Vector *children = Vec_new(2);
        Vec_Push(children, (Obj*)query);
        Vec_Push(children, category_query);
        query = (Query*)ANDQuery_new(children);

        DECREF(children);
        DECREF(category_str);
        DECREF(category_name);
    }
}
</code></pre>
<p>Now when we execute the query…</p>
<pre><code class="language-c">    Hits *hits = IxSearcher_Hits(searcher, (Obj*)query, 0, 10, NULL);
</code></pre>
<p>… we’ll get a result set which is the intersection of the parsed query and
the category query.</p>
<h2>Using TermQuery with full text fields</h2>
<p>When querying full text fields, the easiest way is to create query objects
using QueryParser. But sometimes you want to create TermQuery for a single
term in a FullTextType field directly. In this case, we have to run the
search term through the field’s analyzer to make sure it gets normalized in
the same way as the field’s content.</p>
<pre><code class="language-c">Query*
make_term_query(Schema *schema, String *field, String *term) {
    FieldType *type  = Schema_Fetch_Type(schema, field);
    String    *token = NULL;

    if (FieldType_is_a(type, FULLTEXTTYPE)) {
        // Run the term through the full text analysis chain.
        Analyzer *analyzer = FullTextType_Get_Analyzer((FullTextType*)type);
        Vector   *tokens   = Analyzer_Split(analyzer, term);

        if (Vec_Get_Size(tokens) != 1) {
            // If the term expands to more than one token, or no
            // tokens at all, it will never match a single token in
            // the full text field.
            DECREF(tokens);
            return (Query*)NoMatchQuery_new();
        }

        token = (String*)Vec_Delete(tokens, 0);
        DECREF(tokens);
    }
    else {
        // Exact match for other types.
        token = (String*)INCREF(term);
    }

    TermQuery *term_query = TermQuery_new(field, (Obj*)token);

    DECREF(token);
    return (Query*)term_query;
}
</code></pre>
<h2>Congratulations!</h2>
<p>You’ve made it to the end of the tutorial.</p>
<h2>See Also</h2>
<p>For additional thematic documentation, see the Apache Lucy
<a href="../../../Lucy/Docs/Cookbook.html">Cookbook</a>.</p>
<p>ANDQuery has a companion class, <a href="../../../Lucy/Search/ORQuery.html">ORQuery</a>, and a
close relative, <a href="../../../Lucy/Search/RequiredOptionalQuery.html">RequiredOptionalQuery</a>.</p>
</body>
</html>

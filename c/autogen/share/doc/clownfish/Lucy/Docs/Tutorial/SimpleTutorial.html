<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<!--
***********************************************

!!!! DO NOT EDIT !!!!

This file was auto-generated by cfc.

***********************************************

Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<meta name="viewport" content="width=device-width" />
<title>Lucy::Docs::Tutorial::SimpleTutorial</title>
<style type="text/css">
body {
    max-width: 48em;
    font: 0.85em/1.4 sans-serif;
}
a {
    color: #23b;
}
table {
    border-collapse: collapse;
}
td {
    padding: 0;
}
td.label {
    padding-right: 2em;
    font-weight: bold;
}
dt {
    font-weight: bold;
}
pre {
    border: 1px solid #ccc;
    padding: 0.2em 0.4em;
    background: #f6f6f6;
    font-size: 0.92em;
}
pre a {
    text-decoration: none;
}
pre, code {
    font-family: "Consolas", "Menlo", monospace;
}
span.prefix, span.comment {
    color: #888;
}
</style>
</head>
<body>
<h1>Bare-bones search app.</h1>
<h2>Setup</h2>
<p>Copy the text presentation of the US Constitution from the <code>sample</code> directory
of the Apache Lucy distribution to the base level of your web server’s
<code>htdocs</code> directory.</p>
<pre><code>$ cp -R sample/us_constitution /usr/local/apache2/htdocs/
</code></pre>
<h2>Indexing: indexer.pl</h2>
<p>Our first task will be to create an application called <code>indexer.pl</code> which
builds a searchable “inverted index” from a collection of documents.</p>
<p>After we specify some configuration variables and load all necessary
modules…</p>
<pre><code class="language-c">#include &lt;dirent.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define CFISH_USE_SHORT_NAMES
#define LUCY_USE_SHORT_NAMES
#include &quot;Clownfish/String.h&quot;
#include &quot;Lucy/Simple.h&quot;
#include &quot;Lucy/Document/Doc.h&quot;

const char path_to_index[] = &quot;lucy_index&quot;;
const char uscon_source[]  = &quot;../../common/sample/us_constitution&quot;;
</code></pre>
<p>… we’ll start by creating a <a href="../../../Lucy/Simple.html">Lucy::Simple</a> object, telling it
where we’d like the index to be located and the language of the source
material.</p>
<pre><code class="language-c">int
main() {
    // Initialize the library.
    lucy_bootstrap_parcel();

    String *folder   = Str_newf(&quot;%s&quot;, path_to_index);
    String *language = Str_newf(&quot;en&quot;);
    Simple *lucy     = Simple_new((Obj*)folder, language);
</code></pre>
<p>Next, we’ll add a subroutine which parses our sample documents.</p>
<pre><code class="language-c">Doc*
S_parse_file(const char *filename) {
    size_t bytes = strlen(uscon_source) + 1 + strlen(filename) + 1;
    char *path = (char*)malloc(bytes);
    path[0] = '\0';
    strcat(path, uscon_source);
    strcat(path, &quot;/&quot;);
    strcat(path, filename);

    FILE *stream = fopen(path, &quot;r&quot;);
    if (stream == NULL) {
        perror(path);
        exit(1);
    }

    char *title    = NULL;
    char *bodytext = NULL;
    if (fscanf(stream, &quot;%m[^\r\n] %m[\x01-\x7F]&quot;, &amp;title, &amp;bodytext) != 2) {
        fprintf(stderr, &quot;Can't extract title/bodytext from '%s'&quot;, path);
        exit(1);
    }

    Doc *doc = Doc_new(NULL, 0);

    {
        // Store 'title' field
        String *field = Str_newf(&quot;title&quot;);
        String *value = Str_new_from_utf8(title, strlen(title));
        Doc_Store(doc, field, (Obj*)value);
        DECREF(field);
        DECREF(value);
    }

    {
        // Store 'content' field
        String *field = Str_newf(&quot;content&quot;);
        String *value = Str_new_from_utf8(bodytext, strlen(bodytext));
        Doc_Store(doc, field, (Obj*)value);
        DECREF(field);
        DECREF(value);
    }

    {
        // Store 'url' field
        String *field = Str_newf(&quot;url&quot;);
        String *value = Str_new_from_utf8(filename, strlen(filename));
        Doc_Store(doc, field, (Obj*)value);
        DECREF(field);
        DECREF(value);
    }

    fclose(stream);
    free(bodytext);
    free(title);
    free(path);
    return doc;
}
</code></pre>
<p>Add some elementary directory reading code…</p>
<pre><code class="language-c">    DIR *dir = opendir(uscon_source);
    if (dir == NULL) {
        perror(uscon_source);
        return 1;
    }
</code></pre>
<p>… and now we’re ready for the meat of indexer.pl – which occupies exactly
one line of code.</p>
<pre><code class="language-c">    for (struct dirent *entry = readdir(dir);
         entry;
         entry = readdir(dir)) {

        if (S_ends_with(entry-&gt;d_name, &quot;.txt&quot;)) {
            Doc *doc = S_parse_file(entry-&gt;d_name);
            Simple_Add_Doc(lucy, doc); // ta-da!
            DECREF(doc);
        }
    }

    closedir(dir);

    DECREF(lucy);
    DECREF(language);
    DECREF(folder);
    return 0;
}
</code></pre>
<h2>Search: search.cgi</h2>
<p>As with our indexing app, the bulk of the code in our search script won’t be
Lucy-specific.</p>
<p>The beginning is dedicated to CGI processing and configuration.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define CFISH_USE_SHORT_NAMES
#define LUCY_USE_SHORT_NAMES
#include &quot;Clownfish/String.h&quot;
#include &quot;Lucy/Document/HitDoc.h&quot;
#include &quot;Lucy/Simple.h&quot;

const char path_to_index[] = &quot;lucy_index&quot;;

static void
S_usage_and_exit(const char *arg0) {
    printf(&quot;Usage: %s &lt;querystring&gt;\n&quot;, arg0);
    exit(1);
}

int
main(int argc, char *argv[]) {
    // Initialize the library.
    lucy_bootstrap_parcel();

    if (argc != 2) {
        S_usage_and_exit(argv[0]);
    }

    const char *query_c = argv[1];

    printf(&quot;Searching for: %s\n\n&quot;, query_c);
</code></pre>
<p>Once that’s out of the way, we create our Lucy::Simple object and feed
it a query string.</p>
<pre><code class="language-c">    String *folder   = Str_newf(&quot;%s&quot;, path_to_index);
    String *language = Str_newf(&quot;en&quot;);
    Simple *lucy     = Simple_new((Obj*)folder, language);

    String *query_str = Str_newf(&quot;%s&quot;, query_c);
    Simple_Search(lucy, query_str, 0, 10);
</code></pre>
<p>The value returned by <a href="../../../Lucy/Simple.html#func_Search">Search()</a> is the total number of documents
in the collection which matched the query.  We’ll show this hit count to the
user, and also use it in conjunction with the parameters <code>offset</code> and
<code>num_wanted</code> to break up results into “pages” of manageable size.</p>
<p>Calling <a href="../../../Lucy/Simple.html#func_Search">Search()</a> on our Simple object turns it into an iterator.
Invoking <a href="../../../Lucy/Simple.html#func_Next">Next()</a> now returns hits one at a time as <a href="../../../Lucy/Document/HitDoc.html">HitDoc</a>
objects, starting with the most relevant.</p>
<pre><code class="language-c">    String *title_str = Str_newf(&quot;title&quot;);
    String *url_str   = Str_newf(&quot;url&quot;);
    HitDoc *hit;
    int i = 1;

    // Loop over search results.
    while (NULL != (hit = Simple_Next(lucy))) {
        String *title = (String*)HitDoc_Extract(hit, title_str);
        char *title_c = Str_To_Utf8(title);

        String *url = (String*)HitDoc_Extract(hit, url_str);
        char *url_c = Str_To_Utf8(url);

        printf(&quot;Result %d: %s (%s)\n&quot;, i, title_c, url_c);

        free(url_c);
        free(title_c);
        DECREF(url);
        DECREF(title);
        DECREF(hit);
        i++;
    }

    DECREF(url_str);
    DECREF(title_str);
    DECREF(query_str);
    DECREF(lucy);
    DECREF(language);
    DECREF(folder);
    return 0;
}
</code></pre>
<p>The rest of the script is just text wrangling.</p>
<pre><code>Code example for C is missing</code></pre>
<h2>OK… now what?</h2>
<p>Lucy::Simple is perfectly adequate for some tasks, but it’s not very flexible.
Many people find that it doesn’t do at least one or two things they can’t live
without.</p>
<p>In our next tutorial chapter,
<a href="../../../Lucy/Docs/Tutorial/BeyondSimpleTutorial.html">BeyondSimpleTutorial</a>, we’ll rewrite our
indexing and search scripts using the classes that Lucy::Simple hides
from view, opening up the possibilities for expansion; then, we’ll spend the
rest of the tutorial chapters exploring these possibilities.</p>
</body>
</html>

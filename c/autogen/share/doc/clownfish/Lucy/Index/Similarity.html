<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<!--
***********************************************

!!!! DO NOT EDIT !!!!

This file was auto-generated by cfc.

***********************************************

Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<meta name="viewport" content="width=device-width" />
<title>Lucy::Index::Similarity – C API Documentation</title>
<style type="text/css">
body {
    max-width: 48em;
    font: 0.85em/1.4 sans-serif;
}
a {
    color: #23b;
}
table {
    border-collapse: collapse;
}
td {
    padding: 0;
}
td.label {
    padding-right: 2em;
    font-weight: bold;
}
dt {
    font-weight: bold;
}
pre {
    border: 1px solid #ccc;
    padding: 0.2em 0.4em;
    background: #f6f6f6;
    font-size: 0.92em;
}
pre a {
    text-decoration: none;
}
pre, code {
    font-family: "Consolas", "Menlo", monospace;
}
span.prefix, span.comment {
    color: #888;
}
</style>
</head>
<body>
<h1>Lucy::Index::Similarity</h1>
<table>
<tr>
<td class="label">parcel</td>
<td><a href="../../lucy.html">Lucy</a></td>
</tr>
<tr>
<td class="label">class variable</td>
<td><code><span class="prefix">LUCY_</span>SIMILARITY</code></td>
</tr>
<tr>
<td class="label">struct symbol</td>
<td><code><span class="prefix">lucy_</span>Similarity</code></td>
</tr>
<tr>
<td class="label">class nickname</td>
<td><code><span class="prefix">lucy_</span>Sim</code></td>
</tr>
<tr>
<td class="label">header file</td>
<td><code>Lucy/Index/Similarity.h</code></td>
</tr>
</table>
<h2>Name</h2>
<p>Lucy::Index::Similarity – Judge how well a document matches a query.</p>
<h2>Description</h2>
<p>After determining whether a document matches a given query, a score must be
calculated which indicates how <em>well</em> the document matches the query.  The
Similarity class is used to judge how “similar” the query and the document
are to each other; the closer the resemblance, they higher the document
scores.</p>
<p>The default implementation uses Lucene’s modified cosine similarity
measure.  Subclasses might tweak the existing algorithms, or might be used
in conjunction with custom Query subclasses to implement arbitrary scoring
schemes.</p>
<p>Most of the methods operate on single fields, but some are used to combine
scores from multiple fields.</p>
<h2>Functions</h2>
<dl>
<dt id="func_init">init</dt>
<dd>
<pre><code><span class="prefix">lucy_</span>Similarity*
<span class="prefix">lucy_</span><strong>Sim_init</strong>(
    <span class="prefix">lucy_</span>Similarity *<strong>self</strong>
);
</code></pre>
<p>Constructor. Takes no arguments.</p>
</dd>
</dl>
<h2>Methods</h2>
<dl>
<dt id="func_Length_Norm">Length_Norm</dt>
<dd>
<pre><code>float
<span class="prefix">lucy_</span><strong>Sim_Length_Norm</strong>(
    <span class="prefix">lucy_</span>Similarity *<strong>self</strong>,
    uint32_t <strong>num_tokens</strong>
);
</code></pre>
<p>Dampen the scores of long documents.</p>
<p>After a field is broken up into terms at index-time, each term must be
assigned a weight.  One of the factors in calculating this weight is
the number of tokens that the original field was broken into.</p>
<p>Typically, we assume that the more tokens in a field, the less
important any one of them is – so that, e.g. 5 mentions of “Kafka” in
a short article are given more heft than 5 mentions of “Kafka” in an
entire book.  The default implementation of length_norm expresses this
using an inverted square root.</p>
<p>However, the inverted square root has a tendency to reward very short
fields highly, which isn’t always appropriate for fields you expect to
have a lot of tokens on average.</p>
</dd>
<dt id="func_Destroy">Destroy</dt>
<dd>
<pre><code>void
<span class="prefix">lucy_</span><strong>Sim_Destroy</strong>(
    <span class="prefix">lucy_</span>Similarity *<strong>self</strong>
);
</code></pre>
<p>Generic destructor.  Frees the struct itself but not any complex
member elements.</p>
</dd>
<dt id="func_Equals">Equals</dt>
<dd>
<pre><code>bool
<span class="prefix">lucy_</span><strong>Sim_Equals</strong>(
    <span class="prefix">lucy_</span>Similarity *<strong>self</strong>,
    <span class="prefix">cfish_</span><a href="../../Clownfish/Obj.html">Obj</a> *<strong>other</strong>
);
</code></pre>
<p>Indicate whether two objects are the same.  By default, compares the
memory address.</p>
<dl>
<dt>other</dt>
<dd><p>Another Obj.</p>
</dd>
</dl>
</dd>
</dl>
<h2>Inheritance</h2>
<p>Lucy::Index::Similarity is a <a href="../../Clownfish/Obj.html">Clownfish::Obj</a>.</p>
</body>
</html>

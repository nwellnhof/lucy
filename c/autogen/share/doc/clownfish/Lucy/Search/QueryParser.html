<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<!--
***********************************************

!!!! DO NOT EDIT !!!!

This file was auto-generated by cfc.

***********************************************

Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<meta name="viewport" content="width=device-width" />
<title>Lucy::Search::QueryParser – C API Documentation</title>
<style type="text/css">
body {
    max-width: 48em;
    font: 0.85em/1.4 sans-serif;
}
a {
    color: #23b;
}
table {
    border-collapse: collapse;
}
td {
    padding: 0;
}
td.label {
    padding-right: 2em;
    font-weight: bold;
}
dt {
    font-weight: bold;
}
pre {
    border: 1px solid #ccc;
    padding: 0.2em 0.4em;
    background: #f6f6f6;
    font-size: 0.92em;
}
pre a {
    text-decoration: none;
}
pre, code {
    font-family: "Consolas", "Menlo", monospace;
}
span.prefix, span.comment {
    color: #888;
}
</style>
</head>
<body>
<h1>Lucy::Search::QueryParser</h1>
<table>
<tr>
<td class="label">parcel</td>
<td><a href="../../lucy.html">Lucy</a></td>
</tr>
<tr>
<td class="label">class variable</td>
<td><code><span class="prefix">LUCY_</span>QUERYPARSER</code></td>
</tr>
<tr>
<td class="label">struct symbol</td>
<td><code><span class="prefix">lucy_</span>QueryParser</code></td>
</tr>
<tr>
<td class="label">class nickname</td>
<td><code><span class="prefix">lucy_</span>QParser</code></td>
</tr>
<tr>
<td class="label">header file</td>
<td><code>Lucy/Search/QueryParser.h</code></td>
</tr>
</table>
<h2>Name</h2>
<p>Lucy::Search::QueryParser – Transform a string into a Query object.</p>
<h2>Description</h2>
<p>QueryParser accepts search strings as input and produces
<a href="../../Lucy/Search/Query.html">Query</a> objects, suitable for feeding into
<a href="../../Lucy/Search/IndexSearcher.html">IndexSearcher</a> and other
<a href="../../Lucy/Search/Searcher.html">Searcher</a> subclasses.</p>
<p>The following syntactical constructs are recognized by QueryParser:</p>
<ul>
<li>Boolean operators ‘AND’, ‘OR’, and ‘AND NOT’.</li>
<li>Prepented +plus and -minus, indicating that the labeled entity
should be either required or forbidden – be it a single word, a
phrase, or a parenthetical group.</li>
<li>Logical groups, delimited by parentheses.</li>
<li>Phrases, delimited by double quotes.</li>
</ul>
<p>Additionally, the following syntax can be enabled via <a href="../../Lucy/Search/QueryParser.html#func_Set_Heed_Colons">Set_Heed_Colons()</a>:</p>
<ul>
<li>Field-specific constructs, in the form of ‘fieldname:termtext’ or
‘fieldname:(foo bar)’.  (The field specified by ‘fieldname:’ will be
used instead of the QueryParser’s default fields).</li>
</ul>
<h2>Functions</h2>
<dl>
<dt id="func_new">new</dt>
<dd>
<pre><code><span class="prefix">lucy_</span>QueryParser* <span class="comment">// incremented</span>
<span class="prefix">lucy_</span><strong>QParser_new</strong>(
    <span class="prefix">lucy_</span><a href="../../Lucy/Plan/Schema.html">Schema</a> *<strong>schema</strong>,
    <span class="prefix">lucy_</span><a href="../../Lucy/Analysis/Analyzer.html">Analyzer</a> *<strong>analyzer</strong>,
    <span class="prefix">cfish_</span><a href="../../Clownfish/String.html">String</a> *<strong>default_boolop</strong>,
    <span class="prefix">cfish_</span><a href="../../Clownfish/Vector.html">Vector</a> *<strong>fields</strong>
);
</code></pre>
<p>Constructor.</p>
<dl>
<dt>schema</dt>
<dd><p>A <a href="../../Lucy/Plan/Schema.html">Schema</a>.</p>
</dd>
<dt>analyzer</dt>
<dd><p>An <a href="../../Lucy/Analysis/Analyzer.html">Analyzer</a>.
Ordinarily, the analyzers specified by each field’s definition will be
used, but if <code>analyzer</code> is supplied, it will override and be used for
all fields.  This can lead to mismatches between what is in the index
and what is being searched for, so use caution.</p>
</dd>
<dt>fields</dt>
<dd><p>The names of the fields which will be searched against.
Defaults to those fields which are defined as indexed in the supplied
Schema.</p>
</dd>
<dt>default_boolop</dt>
<dd><p>Two possible values: ‘AND’ and ‘OR’.  The default
is ‘OR’, which means: return documents which match any of the query
terms.  If you want only documents which match all of the query terms,
set this to ‘AND’.</p>
</dd>
</dl>
</dd>
<dt id="func_init">init</dt>
<dd>
<pre><code><span class="prefix">lucy_</span>QueryParser*
<span class="prefix">lucy_</span><strong>QParser_init</strong>(
    <span class="prefix">lucy_</span>QueryParser *<strong>self</strong>,
    <span class="prefix">lucy_</span><a href="../../Lucy/Plan/Schema.html">Schema</a> *<strong>schema</strong>,
    <span class="prefix">lucy_</span><a href="../../Lucy/Analysis/Analyzer.html">Analyzer</a> *<strong>analyzer</strong>,
    <span class="prefix">cfish_</span><a href="../../Clownfish/String.html">String</a> *<strong>default_boolop</strong>,
    <span class="prefix">cfish_</span><a href="../../Clownfish/Vector.html">Vector</a> *<strong>fields</strong>
);
</code></pre>
<p>Initialize a QueryParser.</p>
<dl>
<dt>schema</dt>
<dd><p>A <a href="../../Lucy/Plan/Schema.html">Schema</a>.</p>
</dd>
<dt>analyzer</dt>
<dd><p>An <a href="../../Lucy/Analysis/Analyzer.html">Analyzer</a>.
Ordinarily, the analyzers specified by each field’s definition will be
used, but if <code>analyzer</code> is supplied, it will override and be used for
all fields.  This can lead to mismatches between what is in the index
and what is being searched for, so use caution.</p>
</dd>
<dt>fields</dt>
<dd><p>The names of the fields which will be searched against.
Defaults to those fields which are defined as indexed in the supplied
Schema.</p>
</dd>
<dt>default_boolop</dt>
<dd><p>Two possible values: ‘AND’ and ‘OR’.  The default
is ‘OR’, which means: return documents which match any of the query
terms.  If you want only documents which match all of the query terms,
set this to ‘AND’.</p>
</dd>
</dl>
</dd>
</dl>
<h2>Methods</h2>
<dl>
<dt id="func_Parse">Parse</dt>
<dd>
<pre><code><span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a>* <span class="comment">// incremented</span>
<span class="prefix">lucy_</span><strong>QParser_Parse</strong>(
    <span class="prefix">lucy_</span>QueryParser *<strong>self</strong>,
    <span class="prefix">cfish_</span><a href="../../Clownfish/String.html">String</a> *<strong>query_string</strong>
);
</code></pre>
<p>Build a Query object from the contents of a query string.  At present,
implemented internally by calling <a href="../../Lucy/Search/QueryParser.html#func_Tree">Tree()</a>, <a href="../../Lucy/Search/QueryParser.html#func_Expand">Expand()</a>, and <a href="../../Lucy/Search/QueryParser.html#func_Prune">Prune()</a>.</p>
<dl>
<dt>query_string</dt>
<dd><p>The string to be parsed.  May be NULL.</p>
</dd>
</dl>
<p><strong>Returns:</strong> a Query.</p>
</dd>
<dt id="func_Tree">Tree</dt>
<dd>
<pre><code><span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a>* <span class="comment">// incremented</span>
<span class="prefix">lucy_</span><strong>QParser_Tree</strong>(
    <span class="prefix">lucy_</span>QueryParser *<strong>self</strong>,
    <span class="prefix">cfish_</span><a href="../../Clownfish/String.html">String</a> *<strong>query_string</strong>
);
</code></pre>
<p>Parse the logical structure of a query string, building a tree
comprised of Query objects.  Leaf nodes in the tree will most often be
LeafQuery objects but might be MatchAllQuery or NoMatchQuery objects as
well.  Internal nodes will be objects which subclass PolyQuery:
ANDQuery, ORQuery, NOTQuery, and RequiredOptionalQuery.</p>
<p>The output of <a href="../../Lucy/Search/QueryParser.html#func_Tree">Tree()</a> is an intermediate form which must be passed
through <a href="../../Lucy/Search/QueryParser.html#func_Expand">Expand()</a> before being used to feed a search.</p>
<dl>
<dt>query_string</dt>
<dd><p>The string to be parsed.</p>
</dd>
</dl>
<p><strong>Returns:</strong> a Query.</p>
</dd>
<dt id="func_Expand">Expand</dt>
<dd>
<pre><code><span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a>* <span class="comment">// incremented</span>
<span class="prefix">lucy_</span><strong>QParser_Expand</strong>(
    <span class="prefix">lucy_</span>QueryParser *<strong>self</strong>,
    <span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a> *<strong>query</strong>
);
</code></pre>
<p>Walk the hierarchy of a Query tree, descending through all PolyQuery
nodes and calling <a href="../../Lucy/Search/QueryParser.html#func_Expand_Leaf">Expand_Leaf()</a> on any LeafQuery nodes encountered.</p>
<dl>
<dt>query</dt>
<dd><p>A Query object.</p>
</dd>
</dl>
<p><strong>Returns:</strong> A Query – usually the same one that was supplied after
in-place modification, but possibly another.</p>
</dd>
<dt id="func_Expand_Leaf">Expand_Leaf</dt>
<dd>
<pre><code><span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a>* <span class="comment">// incremented</span>
<span class="prefix">lucy_</span><strong>QParser_Expand_Leaf</strong>(
    <span class="prefix">lucy_</span>QueryParser *<strong>self</strong>,
    <span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a> *<strong>query</strong>
);
</code></pre>
<p>Convert a LeafQuery into either a TermQuery, a PhraseQuery, or an
ORQuery joining multiple TermQueries/PhraseQueries to accommodate
multiple fields.  LeafQuery text will be passed through the relevant
Analyzer for each field.  Quoted text will be transformed into
PhraseQuery objects.  Unquoted text will be converted to either a
TermQuery or a PhraseQuery depending on how many tokens are generated.</p>
<dl>
<dt>query</dt>
<dd><p>A Query.  Only LeafQuery objects will be processed; others
will be passed through.</p>
</dd>
</dl>
<p><strong>Returns:</strong> A Query.</p>
</dd>
<dt id="func_Prune">Prune</dt>
<dd>
<pre><code><span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a>* <span class="comment">// incremented</span>
<span class="prefix">lucy_</span><strong>QParser_Prune</strong>(
    <span class="prefix">lucy_</span>QueryParser *<strong>self</strong>,
    <span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a> *<strong>query</strong>
);
</code></pre>
<p>Prevent certain Query structures from returning too many results.
Query objects built via <a href="../../Lucy/Search/QueryParser.html#func_Tree">Tree()</a> and <a href="../../Lucy/Search/QueryParser.html#func_Expand">Expand()</a> can generate “return the
world” result sets, such as in the case of
<code>NOT a_term_not_in_the_index</code>; <a href="../../Lucy/Search/QueryParser.html#func_Prune">Prune()</a> walks the hierarchy
and eliminates such branches.</p>
<pre><code> 'NOT foo'               =&gt; [NOMATCH]
 'foo OR NOT bar'        =&gt; 'foo'
 'foo OR (-bar AND -baz) =&gt; 'foo'
</code></pre>
<p><a href="../../Lucy/Search/QueryParser.html#func_Prune">Prune()</a> also eliminates some double-negative constructs – even though
such constructs may not actually return the world:</p>
<pre><code> 'foo AND -(-bar)'      =&gt; 'foo'
</code></pre>
<p>In this example, safety is taking precedence over logical consistency.
If you want logical consistency instead, call <a href="../../Lucy/Search/QueryParser.html#func_Tree">Tree()</a> then <a href="../../Lucy/Search/QueryParser.html#func_Expand">Expand()</a>,
skipping <a href="../../Lucy/Search/QueryParser.html#func_Prune">Prune()</a>.</p>
<dl>
<dt>query</dt>
<dd><p>A Query.</p>
</dd>
</dl>
<p><strong>Returns:</strong> a Query; in most cases, the supplied Query after in-place
modification.</p>
</dd>
<dt id="func_Make_Term_Query">Make_Term_Query</dt>
<dd>
<pre><code><span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a>* <span class="comment">// incremented</span>
<span class="prefix">lucy_</span><strong>QParser_Make_Term_Query</strong>(
    <span class="prefix">lucy_</span>QueryParser *<strong>self</strong>,
    <span class="prefix">cfish_</span><a href="../../Clownfish/String.html">String</a> *<strong>field</strong>,
    <span class="prefix">cfish_</span><a href="../../Clownfish/Obj.html">Obj</a> *<strong>term</strong>
);
</code></pre>
<p>Factory method creating a TermQuery.</p>
<dl>
<dt>field</dt>
<dd><p>Field name.</p>
</dd>
<dt>term</dt>
<dd><p>Term text.</p>
</dd>
</dl>
<p><strong>Returns:</strong> A Query.</p>
</dd>
<dt id="func_Make_Phrase_Query">Make_Phrase_Query</dt>
<dd>
<pre><code><span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a>* <span class="comment">// incremented</span>
<span class="prefix">lucy_</span><strong>QParser_Make_Phrase_Query</strong>(
    <span class="prefix">lucy_</span>QueryParser *<strong>self</strong>,
    <span class="prefix">cfish_</span><a href="../../Clownfish/String.html">String</a> *<strong>field</strong>,
    <span class="prefix">cfish_</span><a href="../../Clownfish/Vector.html">Vector</a> *<strong>terms</strong>
);
</code></pre>
<p>Factory method creating a PhraseQuery.</p>
<dl>
<dt>field</dt>
<dd><p>Field that the phrase must occur in.</p>
</dd>
<dt>terms</dt>
<dd><p>Ordered array of terms that must match.</p>
</dd>
</dl>
<p><strong>Returns:</strong> A Query.</p>
</dd>
<dt id="func_Make_OR_Query">Make_OR_Query</dt>
<dd>
<pre><code><span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a>* <span class="comment">// incremented</span>
<span class="prefix">lucy_</span><strong>QParser_Make_OR_Query</strong>(
    <span class="prefix">lucy_</span>QueryParser *<strong>self</strong>,
    <span class="prefix">cfish_</span><a href="../../Clownfish/Vector.html">Vector</a> *<strong>children</strong>
);
</code></pre>
<p>Factory method creating an ORQuery.</p>
<dl>
<dt>children</dt>
<dd><p>Array of child Queries.</p>
</dd>
</dl>
<p><strong>Returns:</strong> A Query.</p>
</dd>
<dt id="func_Make_AND_Query">Make_AND_Query</dt>
<dd>
<pre><code><span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a>* <span class="comment">// incremented</span>
<span class="prefix">lucy_</span><strong>QParser_Make_AND_Query</strong>(
    <span class="prefix">lucy_</span>QueryParser *<strong>self</strong>,
    <span class="prefix">cfish_</span><a href="../../Clownfish/Vector.html">Vector</a> *<strong>children</strong>
);
</code></pre>
<p>Factory method creating an ANDQuery.</p>
<dl>
<dt>children</dt>
<dd><p>Array of child Queries.</p>
</dd>
</dl>
<p><strong>Returns:</strong> A Query.</p>
</dd>
<dt id="func_Make_NOT_Query">Make_NOT_Query</dt>
<dd>
<pre><code><span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a>* <span class="comment">// incremented</span>
<span class="prefix">lucy_</span><strong>QParser_Make_NOT_Query</strong>(
    <span class="prefix">lucy_</span>QueryParser *<strong>self</strong>,
    <span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a> *<strong>negated_query</strong>
);
</code></pre>
<p>Factory method creating a NOTQuery.</p>
<dl>
<dt>negated_query</dt>
<dd><p>Query to be inverted.</p>
</dd>
</dl>
<p><strong>Returns:</strong> A Query.</p>
</dd>
<dt id="func_Make_Req_Opt_Query">Make_Req_Opt_Query</dt>
<dd>
<pre><code><span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a>* <span class="comment">// incremented</span>
<span class="prefix">lucy_</span><strong>QParser_Make_Req_Opt_Query</strong>(
    <span class="prefix">lucy_</span>QueryParser *<strong>self</strong>,
    <span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a> *<strong>required_query</strong>,
    <span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a> *<strong>optional_query</strong>
);
</code></pre>
<p>Factory method creating a RequiredOptionalQuery.</p>
<dl>
<dt>required_query</dt>
<dd><p>Query must must match.</p>
</dd>
<dt>optional_query</dt>
<dd><p>Query which should match.</p>
</dd>
</dl>
<p><strong>Returns:</strong> A Query.</p>
</dd>
<dt id="func_Set_Heed_Colons">Set_Heed_Colons</dt>
<dd>
<pre><code>void
<span class="prefix">lucy_</span><strong>QParser_Set_Heed_Colons</strong>(
    <span class="prefix">lucy_</span>QueryParser *<strong>self</strong>,
    bool <strong>heed_colons</strong>
);
</code></pre>
<p>Enable/disable parsing of <code>fieldname:foo</code> constructs.</p>
</dd>
<dt id="func_Destroy">Destroy</dt>
<dd>
<pre><code>void
<span class="prefix">lucy_</span><strong>QParser_Destroy</strong>(
    <span class="prefix">lucy_</span>QueryParser *<strong>self</strong>
);
</code></pre>
<p>Generic destructor.  Frees the struct itself but not any complex
member elements.</p>
</dd>
</dl>
<h2>Inheritance</h2>
<p>Lucy::Search::QueryParser is a <a href="../../Clownfish/Obj.html">Clownfish::Obj</a>.</p>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<!--
***********************************************

!!!! DO NOT EDIT !!!!

This file was auto-generated by cfc.

***********************************************

Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<meta name="viewport" content="width=device-width" />
<title>Lucy::Search::Compiler – C API Documentation</title>
<style type="text/css">
body {
    max-width: 48em;
    font: 0.85em/1.4 sans-serif;
}
a {
    color: #23b;
}
table {
    border-collapse: collapse;
}
td {
    padding: 0;
}
td.label {
    padding-right: 2em;
    font-weight: bold;
}
dt {
    font-weight: bold;
}
pre {
    border: 1px solid #ccc;
    padding: 0.2em 0.4em;
    background: #f6f6f6;
    font-size: 0.92em;
}
pre a {
    text-decoration: none;
}
pre, code {
    font-family: "Consolas", "Menlo", monospace;
}
span.prefix, span.comment {
    color: #888;
}
</style>
</head>
<body>
<h1>Lucy::Search::Compiler</h1>
<table>
<tr>
<td class="label">parcel</td>
<td><a href="../../lucy.html">Lucy</a></td>
</tr>
<tr>
<td class="label">class variable</td>
<td><code><span class="prefix">LUCY_</span>COMPILER</code></td>
</tr>
<tr>
<td class="label">struct symbol</td>
<td><code><span class="prefix">lucy_</span>Compiler</code></td>
</tr>
<tr>
<td class="label">class nickname</td>
<td><code><span class="prefix">lucy_</span>Compiler</code></td>
</tr>
<tr>
<td class="label">header file</td>
<td><code>Lucy/Search/Compiler.h</code></td>
</tr>
</table>
<h2>Name</h2>
<p>Lucy::Search::Compiler – Query-to-Matcher compiler.</p>
<h2>Description</h2>
<p>The purpose of the Compiler class is to take a specification in the form of
a <a href="../../Lucy/Search/Query.html">Query</a> object and compile a
<a href="../../Lucy/Search/Matcher.html">Matcher</a> object that can do real work.</p>
<p>The simplest Compiler subclasses – such as those associated with
constant-scoring Query types – might simply implement a <a href="../../Lucy/Search/Compiler.html#func_Make_Matcher">Make_Matcher()</a>
method which passes along information verbatim from the Query to the
Matcher’s constructor.</p>
<p>However it is common for the Compiler to perform some calculations which
affect it’s “weight” – a floating point multiplier that the Matcher will
factor into each document’s score.  If that is the case, then the Compiler
subclass may wish to override <a href="../../Lucy/Search/Compiler.html#func_Get_Weight">Get_Weight()</a>, <a href="../../Lucy/Search/Compiler.html#func_Sum_Of_Squared_Weights">Sum_Of_Squared_Weights()</a>, and
<a href="../../Lucy/Search/Compiler.html#func_Apply_Norm_Factor">Apply_Norm_Factor()</a>.</p>
<p>Compiling a Matcher is a two stage process.</p>
<p>The first stage takes place during the Compiler’s construction, which is
where the Query object meets a <a href="../../Lucy/Search/Searcher.html">Searcher</a>
object for the first time.  Searchers operate on a specific document
collection and they can tell you certain statistical information about the
collection – such as how many total documents are in the collection, or
how many documents in the collection a particular term is present in.
Lucy’s core Compiler classes plug this information into the classic
TF/IDF weighting algorithm to adjust the Compiler’s weight; custom
subclasses might do something similar.</p>
<p>The second stage of compilation is <a href="../../Lucy/Search/Compiler.html#func_Make_Matcher">Make_Matcher()</a>, method, which is where
the Compiler meets a <a href="../../Lucy/Index/SegReader.html">SegReader</a> object.
SegReaders are associated with a single segment within a single index on a
single machine, and are thus lower-level than Searchers, which may
represent a document collection spread out over a search cluster
(comprising several indexes and many segments).  The Compiler object can
use new information supplied by the SegReader – such as whether a term is
missing from the local index even though it is present within the larger
collection represented by the Searcher – when figuring out what to feed to
the Matchers’s constructor, or whether <a href="../../Lucy/Search/Compiler.html#func_Make_Matcher">Make_Matcher()</a> should return a
Matcher at all.</p>
<h2>Functions</h2>
<dl>
<dt id="func_init">init</dt>
<dd>
<pre><code><span class="prefix">lucy_</span>Compiler*
<span class="prefix">lucy_</span><strong>Compiler_init</strong>(
    <span class="prefix">lucy_</span>Compiler *<strong>self</strong>,
    <span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a> *<strong>parent</strong>,
    <span class="prefix">lucy_</span><a href="../../Lucy/Search/Searcher.html">Searcher</a> *<strong>searcher</strong>,
    <span class="prefix">lucy_</span><a href="../../Lucy/Index/Similarity.html">Similarity</a> *<strong>similarity</strong>,
    float <strong>boost</strong>
);
</code></pre>
<p>Abstract initializer.</p>
<dl>
<dt>parent</dt>
<dd><p>The parent Query.</p>
</dd>
<dt>searcher</dt>
<dd><p>A Lucy::Search::Searcher, such as an
IndexSearcher.</p>
</dd>
<dt>similarity</dt>
<dd><p>A Similarity.</p>
</dd>
<dt>boost</dt>
<dd><p>An arbitrary scoring multiplier.  Defaults to the boost of
the parent Query.</p>
</dd>
</dl>
</dd>
</dl>
<h2>Methods</h2>
<dl>
<dt id="func_Make_Matcher">Make_Matcher <span class="comment">(abstract)</span></dt>
<dd>
<pre><code><span class="prefix">lucy_</span><a href="../../Lucy/Search/Matcher.html">Matcher</a>* <span class="comment">// incremented</span>
<span class="prefix">lucy_</span><strong>Compiler_Make_Matcher</strong>(
    <span class="prefix">lucy_</span>Compiler *<strong>self</strong>,
    <span class="prefix">lucy_</span><a href="../../Lucy/Index/SegReader.html">SegReader</a> *<strong>reader</strong>,
    bool <strong>need_score</strong>
);
</code></pre>
<p>Factory method returning a Matcher.</p>
<dl>
<dt>reader</dt>
<dd><p>A SegReader.</p>
</dd>
<dt>need_score</dt>
<dd><p>Indicate whether the Matcher must implement <a href="../../Lucy/Search/Matcher.html#func_Score">Score()</a>.</p>
</dd>
</dl>
<p><strong>Returns:</strong> a Matcher, or NULL if the Matcher would have matched
no documents.</p>
</dd>
<dt id="func_Get_Weight">Get_Weight</dt>
<dd>
<pre><code>float
<span class="prefix">lucy_</span><strong>Compiler_Get_Weight</strong>(
    <span class="prefix">lucy_</span>Compiler *<strong>self</strong>
);
</code></pre>
<p>Return the Compiler’s numerical weight, a scoring multiplier.  By
default, returns the object’s boost.</p>
</dd>
<dt id="func_Get_Similarity">Get_Similarity</dt>
<dd>
<pre><code><span class="prefix">lucy_</span><a href="../../Lucy/Index/Similarity.html">Similarity</a>*
<span class="prefix">lucy_</span><strong>Compiler_Get_Similarity</strong>(
    <span class="prefix">lucy_</span>Compiler *<strong>self</strong>
);
</code></pre>
<p>Accessor for the Compiler’s Similarity object.</p>
</dd>
<dt id="func_Get_Parent">Get_Parent</dt>
<dd>
<pre><code><span class="prefix">lucy_</span><a href="../../Lucy/Search/Query.html">Query</a>*
<span class="prefix">lucy_</span><strong>Compiler_Get_Parent</strong>(
    <span class="prefix">lucy_</span>Compiler *<strong>self</strong>
);
</code></pre>
<p>Accessor for the Compiler’s parent Query object.</p>
</dd>
<dt id="func_Sum_Of_Squared_Weights">Sum_Of_Squared_Weights</dt>
<dd>
<pre><code>float
<span class="prefix">lucy_</span><strong>Compiler_Sum_Of_Squared_Weights</strong>(
    <span class="prefix">lucy_</span>Compiler *<strong>self</strong>
);
</code></pre>
<p>Compute and return a raw weighting factor.  (This quantity is used by
<a href="../../Lucy/Search/Compiler.html#func_Normalize">Normalize()</a>).  By default, simply returns 1.0.</p>
</dd>
<dt id="func_Apply_Norm_Factor">Apply_Norm_Factor</dt>
<dd>
<pre><code>void
<span class="prefix">lucy_</span><strong>Compiler_Apply_Norm_Factor</strong>(
    <span class="prefix">lucy_</span>Compiler *<strong>self</strong>,
    float <strong>factor</strong>
);
</code></pre>
<p>Apply a floating point normalization multiplier.  For a TermCompiler,
this involves multiplying its own weight by the supplied factor;
combining classes such as ORCompiler would apply the factor recursively
to their children.</p>
<p>The default implementation is a no-op; subclasses may wish to multiply
their internal weight by the supplied factor.</p>
<dl>
<dt>factor</dt>
<dd><p>The multiplier.</p>
</dd>
</dl>
</dd>
<dt id="func_Normalize">Normalize</dt>
<dd>
<pre><code>void
<span class="prefix">lucy_</span><strong>Compiler_Normalize</strong>(
    <span class="prefix">lucy_</span>Compiler *<strong>self</strong>
);
</code></pre>
<p>Take a newly minted Compiler object and apply query-specific
normalization factors.  Should be invoked by Query subclasses during
<a href="../../Lucy/Search/Compiler.html#func_Make_Compiler">Make_Compiler()</a> for top-level nodes.</p>
<p>For a TermQuery, the scoring formula is approximately:</p>
<pre><code>(tf_d * idf_t / norm_d) * (tf_q * idf_t / norm_q)
</code></pre>
<p><a href="../../Lucy/Search/Compiler.html#func_Normalize">Normalize()</a> is theoretically concerned with applying the second half of
that formula to a the Compiler’s weight. What actually happens depends
on how the Compiler and Similarity methods called internally are
implemented.</p>
</dd>
<dt id="func_Equals">Equals</dt>
<dd>
<pre><code>bool
<span class="prefix">lucy_</span><strong>Compiler_Equals</strong>(
    <span class="prefix">lucy_</span>Compiler *<strong>self</strong>,
    <span class="prefix">cfish_</span><a href="../../Clownfish/Obj.html">Obj</a> *<strong>other</strong>
);
</code></pre>
<p>Indicate whether two objects are the same.  By default, compares the
memory address.</p>
<dl>
<dt>other</dt>
<dd><p>Another Obj.</p>
</dd>
</dl>
</dd>
<dt id="func_To_String">To_String</dt>
<dd>
<pre><code><span class="prefix">cfish_</span><a href="../../Clownfish/String.html">String</a>* <span class="comment">// incremented</span>
<span class="prefix">lucy_</span><strong>Compiler_To_String</strong>(
    <span class="prefix">lucy_</span>Compiler *<strong>self</strong>
);
</code></pre>
<p>Generic stringification: “ClassName@hex_mem_address”.</p>
</dd>
<dt id="func_Destroy">Destroy</dt>
<dd>
<pre><code>void
<span class="prefix">lucy_</span><strong>Compiler_Destroy</strong>(
    <span class="prefix">lucy_</span>Compiler *<strong>self</strong>
);
</code></pre>
<p>Generic destructor.  Frees the struct itself but not any complex
member elements.</p>
</dd>
</dl>
<h2>Inheritance</h2>
<p>Lucy::Search::Compiler is a <a href="../../Lucy/Search/Query.html">Lucy::Search::Query</a> is a <a href="../../Clownfish/Obj.html">Clownfish::Obj</a>.</p>
</body>
</html>
